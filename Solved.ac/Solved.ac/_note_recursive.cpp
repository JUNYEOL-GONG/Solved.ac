#include <bits/stdc++.h>
using namespace std;

/// 절차 지향적 사고 vs 귀납적 사고
// 
// 재귀적이라는 뜻은 귀납적이라는 것이다.
// 
// '올바른 쌍의 괄호 구하기'와 같은 문제에서는
// 스택에 '{'를 넣고 '}'가 나오면 스택이 비어있는 지 확인하고,
// 스택의 top이 짝이 맞는 지 확인하고 하는 것과 같이 '순서에 따라 해야할 일이 정해져 있는' 코딩을 해왔다.
//
// 재귀와 같이 귀납적인 방식이 어떤 차이가 있을까?
// 도미노를 예로 들어보면,, 1 ~ N번 까지의 도미노가 있을 때,
// 어떻게 모든 도미노가 쓰러질 수 있는 지를 물어보면,
// 1 -> 2 -> 3 -> 4 -> 5 ... 각각 연쇄적으로 이전의 도미노가 쓰러뜨리기 때문에
// 모든 도미노는 쓰러진다.. 와 같이 앞에 여러 예시들이 나열되고, 이후에 결과가 오는 방식이 바로
// 귀납적 추론 방식이다.
// 
// 수학적 귀납법으로 설명하자면,
// 1번 도미노가 쓰러지면, 2번 도미노가 쓰러진다.
// 2번 도미노가 쓰러지면, 3번 도미노가 쓰러진다.
// K번 도미노가 쓰러지면, K + 1번 도미노가 쓰러진다.
// 이렇게 설명할 수 있는데, 이러한 성질처럼
// 재귀 함수의 귀납적 방식에서도,
// 1번 도미노가 쓰러지면 2번 도미노가 쓰러진다.
// 그러므로 K번 도미노가 쓰러지면 K + 1번 도미노가 쓰러진다
// => 로 바로 갈 수 있어야 한다.
// 즉, 그동안 해오면 절차지향적 사고를 완전히 갈아 엎어야 한다.
//

/// <summary>
/// 1부터 N까지의 수를 출력하는 함수
/// 
/// 절차지향적 사고방식
/// => 함수가 동작하는 흐름을 '그대로 따라간다'
/// -> 3 입력
/// -> func1(2) 호출
/// -> func1(1) 호출
/// -> func1(0) 호출
/// -> 1 출력
/// -> 2 출력
/// -> 3 출력
/// 
/// 귀납적 사고방식
/// => 과정을 하나 하나 따라가는 대신, 귀납적인 사고를 통해서 이해해야 한다.
/// -> func1(1)이 1을 출력한다
/// -> func1(k)가 k, k-1, k-2 ... 1을 출력하면 (가정을 했다)
/// -> func1(k+1)은 k+1, k, k-1 ... 1을 출력한다
/// 
/// </summary>
/// <param name="N"></param>
void func1(int N) {
	if (N == 0) return;
	func1(N - 1);
	cout << N << ' ';
}

// 1부터 N까지의 합을 구하는 함수
int Sum(int N)	// 인자를 활용해야 한다
{
	// N부터 1까지 줄여가며 합을 구한다
	if (N > 0) {
		N += Sum(N - 1);
	}

	return N;
}

int main() {

	int N = 3;

	/*
	int sum = Sum(N);
	cout << sum << '\n';
	*/

	func1(N);




	return 0;
}