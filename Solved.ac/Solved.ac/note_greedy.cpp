// 직관적으로 보이는 풀이의 시간복잡도로는 문제의 시간 제한 안에 들어올 수 없을 때
// 시간복잡도를 더 낮출 수 없을까 '관찰'을 하게된다

// ** 이상적인 풀이 흐름 **
// 1. '관찰'을 통해 탐색 범위를 줄이는 방법을 고안
// 2. 탐색 범위를 줄여도 올바른 결과를 낸다는 사실을 수학적으로 증명한다
// 3. 구현해서 문제를 통과한다

// ** 절망적인 풀이 흐름 **
// 1. '관찰'을 통해 탐색 범위를 줄이는 '잘못된' 방법을 고안
// 2. 탐색 범위를 줄여도 올바른 결과를 낸다는 강한 믿음을 가진다
// 3. 믿음을 가지고 구현했는데 계속 틀린다

// 거의 똑같은 문제를 풀어봤거나, 나의 그리디 풀이를 100% 확인할 수 있다면
//		=> 바로 구현해서 풀어낸다
// 그게 아니라면 '그리디 알고리즘 풀이가 틀린 것인지', '그리디 알고리즘의 사용 자체가 틀린 것인지' 알 수 없기 때문에
//		=> 일단은 넘어가고 다른 문제를 풀어보고, 풀 게 없다면 20 ~ 40분 남은 시점에 다시 이 문제를 풀도록한다.

// 코딩 테스트에서는 풀이의 정당성을 꼼꼼하게 체크하고 가기 보다는
// 빠르게 넘어가고 다른 문제를 다 풀고난 뒤, 마지막에 시간이 남았을 때 다시 돌아와 풀어본다

// 즉, '그리디 알고리즘'은 붙잡고 있는다고 해서 풀리는 문제가 아니라는 뜻이다