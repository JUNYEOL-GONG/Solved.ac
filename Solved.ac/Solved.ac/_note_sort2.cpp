#include <iostream>
using namespace std;

// <Counting Sort (카운팅 정렬)>
// -> 정렬 알고리즘 중에서 가장 쉬운 알고리즘
// 
// 원소의 개수를 카운팅해서 배열의 '인덱스에는 숫자'를,
// '요소에는 개수'를 저장해둔 후, 그냥 순서대로 출력하면 된다.
//
// 만약 0부터 9사이라면 freq[10] 배열에 담아서 사용할 수 있고
// 0부터 9999사이라면 freq[10000] 배열에 담아서 사용할 수 있겠지만,
// 0부터 999999999(9억)사이라면 freq[10억]은 4 x 10^9 byte가 필요하므로 사용이 불가능하다.
// 코딩테스트에서 메모리 제한이 512MB라고 해도 512 x 10^6 byte => 1.28억개의 배열 밖에 선언할 수 없다
//
// 이론적으로는 0에서 1억사이라면 카운팅 정렬을 사용할 수 있지만,
// 웬만하면 1000만 이하일때는 카운팅 정렬을 사용한다고 생각하자
//
//
// <Radix Sort (라딕스 정렬)>
// 자릿수를 이용해서 정렬을 수행하는 알고리즘으로, Counting Sort를 응용한 것이라고 생각할 수 있다.
// 
// 배열이 다음과 같이 있을 경우
// : [012, 421, 046, 674, 103, 502, 007, 100, 021, 545]
// 
// 1의 자릿수를 기준으로 Counting Sort한다.
// : [100, 421, 021, 012, 502, 103, 674, 545, 046, 007]
// 10의 자릿수를 기준으로 Counting Sort한다.
// : [100, 502, 103, 007, 012, 421, 021, 545, 046, 674]
// 100의 자릿수를 기준으로 Counting Sort한다.
// : [007, 012, 021, 046, 100, 103, 421, 502, 545, 674]
//
// 정렬이 완료되었다.("짝짝짝짝")
//
// 여기서의 핵심은 100의 자리수를 기준으로 정렬하기 전에 1의 자릿수, 10의 자릿수를 기준으로 정렬하는 과정에서,
// 100의 자릿수를 기준으로 정렬할때 '동일한 값을 가지는 요소에 대해서 정렬하는 효과'를 가지고,
// 이 정렬되는 효과는 '이전 자릿수의 정렬 결과의 순서를 유지하는 안정성'을 가지기 때문에 최종적으로 완전히 정렬된 배열이 만들어진다.
//
// 이 원리는 421 < 464 임을 증명하는 과정과 동일하다
// 100의 자리 숫자는 동일하다 4 = 4
// 10의 자리 숫자는 오른쪽 값이 더 크다 2 < 6
// 따라서 464가 421보다 크다.
//
//
// <Comprison Sort vs Non-Comprison Sort>
// Select, Bubble, Merge, Quick 모두 다른 요소와 비교하며 정렬을 진행하는 반면,
// Counting, Radix는 다른 요소들과의 비교 없이 개수를 세서 정렬하는 알고리즘이다.
// 
// 
// 근데 Select, Bubble, Merge, Quick, Counting, Radix 라는 다양한 알고리즘을 배웠는데,
// 어떤걸 코딩테스트에서 사용해야 할까?
// 정답은 std:sort()를 사용한다! 이다.
//
// 이유 1: 퀵소트를 기반으로 하지만, 리스트가 불균등하게 쪼개지며 재귀의 깊이가 너무 깊어지면 O(NlogN)이 보장되는 알고리즘으로 정렬을 실행하기 때문에,
// 최종적으로 std::sort() 함수는 O(NlogN)의 시간복잡도를 보장한다 (Stable Sort는 아니라는 함정 ! - 동일한 우선순위를 가진 원소들 사이에서의 상대적인 순서가 보존되지 않을 수 있으므로, 필요하다면 stable_sort() 함수를 사용한다)
//
// 이유 2: std::sort() 함수는 pair<> 혹은 tuple과 같은 컨테이너를 우리가 당연하게 생각하는대로 첫 번째 원소의 대소를 비교하고, 그 다음 두 번째 원소의 대소를 비교하는 방식을 자체적으로 지원한다.
//
// 이유 3: 비교함수 bool compare(int a, int b) 함수를 직접 정의해서 넣을 수 있다
// 주의 사항 1 -> 비교하는 두 값의 우선순위가 같을 따 false를 반환하기 때문에 if(a >= b) return true 가 아닌, return a > b를 해줘야 한다.
// 주의 사항 2 -> 비교하는 값의 parameter로 클래스 객체를 전달할 시 값 복사가 되기 때문에 reference를 사용한다.