// 연결 리스트(링크드 리스트)는 각 요소가 다음 요소를 가리키는 구조
//
// 1. K번째 원소를 확인 / 변경하기 위해 O(K)의 시간복잡도가 필요하다
// 3 -> 13 -> 72 -> 5 이러한 리스트에서 72를 찾기 위해서 3 -> 13 -> 72 이 과정을 거쳐야 한다
// 반면에 배열은 O(1)로 확인 / 변경이 가능하다
// 
// 2. 임의의 위치에 원소를 추가 / 삭제는 O(1)의 시간복잡도가 필요하다
// 원소를 추가하거나 제거하면서 원소들을 당기거나 밀거나 할 필요가 없다
// 그런 의미에서 배열은 O(K)가 발생한다
// cf) 여기서 말한는 O(1)은 어디에 넣을지를 알고 가리키는 주소만 변경해주면 되는 경우를 말한다
// 만약 어디에 넣을지가 정해져 있지 않다면, 그 요소를 찾는 비용도 발생하니 O(1)이라고 말할 수 없다
//
// 3. 원소들이 메모리 상에 연속해 있지 않아서 'Cache Hit Rate'가 낮다
//
// 4. 배열에 비해 연결 리스트는 추가적으로 필요한 공간(Overhead)이 상대적으로 크다
// 이 오버헤드에는 O(N)의 메모리 추가 비용이 든다. 왜냐하면 N개의 요소만큼 포인팅하고 있기 때문이다.

// 단일 연결 리스트와 이중 연결 리스트가 있다
// 단일 연결 리스트는 다음 요소의 위치만 가지고 있는데
// 이중 연결 리스트는 이전 요소의 위치 또한 가지고 있다
// cf) 참고로 STL의 List는 '이중 연결 리스트'이다

// 연결 리스트는 배열처럼 메모리 상에 연속해 있지는 않지만
// 원소들간의 순서는 있다. (1번째 원소, 2번째 원소 ..)
// -> 선형 자료구조 (시퀀스 컨테이너)

// 연결 리스트는 메모장과 같은 '텍스트 에디터'에서 효율적으로 구현된다
// 마우스 커서가 위치하는 곳에 입력값을 출력해야 하는데
// 배열을 사용하면 입력의 추가 / 삭제가 O(N)이므로
// 추가 / 삭제가 O(1)인 '연결 리스트'를 사용해 구현한다