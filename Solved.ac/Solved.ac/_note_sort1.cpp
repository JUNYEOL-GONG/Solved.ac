// basic sort
// 
// 1. 선택 정렬
// 
// 책장의 서로 다른 높이의 무작위 배치된 책을 정렬하라고 하면
// 가장 먼저 떠오르는 방식이 뭐임..?
// 
// 대부분은 가장 기다란걸 찾아서
// 가장 끝에 놓는 방식을 생각하지
// 
// 이게 '선택 정렬'
// 가장 짧거나 긴거를 '선택'하는 거니까
// 
// 2. 버블 정렬
//
// 앞에서부터 인접한 두 원소를 비교하며
// 큰 수를 오른쪽으로 스왑하면
// 결국 한바퀴 돌았을때는 가장 오른쪽에 제일 큰 값이 배치된다
// 
// 이게 '버블 정렬'
// 인접한 두 원소가 거품같다고 해서
// 
// 3. 병합 정렬
// 
// * 분할
// 크기 N의 배열이 있고, 이를 크기 1까지 분할한다
// 배열의 크기 N을 2^k개 라고 했을때
// 분할 과정에서 1 + 2 + 4 + 8 + ... + 2^k가 된다
// 등비수열의 합 공식에 의해 2^(k+1) - 1이 되고
// 이는 곧 2N - 1임을 말한다
// 따라서 병합 정렬의 '분할'은 시간복잡도 O(N)이다
// 
// * 병합
// 길이가 A, B인 두 정렬된 배열을 하나로 합치는 과정의
// 시간복잡도는 O(A + B)였다 -> Merge() 함수 참고
// O(1+1) + O(1+1) + O(1+1) + O(1+1) = O(8)
// O(2+2) + O(2+2) = O(8)
// O(4+4) = O(8)
// O(8)
// 이렇게 각 레벨에서 O(N)으로 병합하고
// 이는 K개가 있으므로
// O(N * K) -> 즉 O(N * logN)이 된다
// 따라서 병합 정렬의 '병합'은 시간복잡도 O(NlogN)이다
//
// => 총 시간 복잡도는 O(N) + O(NlogN) = O(NlogN)
//
// Stable Sort (면접에서 뽐내기 좋음)
// merget sort는 stable sort이다
// 21(빨강) 21(파랑) 21(초록) 38
// 나이순으로 정렬하면 이것도 맞지만, 다른 경우도 존재한다
// 그런데 merge sort는 이러한 순서를 보존하면서 정렬하기 때문에 stable sort라고 한다
//
// 4. 퀵 정렬
//
// 대부분의 STL은 퀵 정렬 바탕으로 만들어져 있다 (너무 너무 빨라서)
// 하지만 STL을 사용하지 못하는 상황에는 귁 정렬 대신 병합 정렬을 사용한다
// 왜? -> 몰라 그냥 퀵 정렬 대신 '힙 정렬'이나 '병합 정렬' 사용하래
//
// <pivot의 올바른 위치를 찾는 방법>
//
// 1. 임시 배열을 이용하기
// 임시 배열 tmp를 만들고 거기에 pivot보다 작은 것 부터 담고
// pivot을 담고
// pivot보다 큰 것을 담으면 된다
//
// 하지만 이 방식은 퀵 정렬을 사용하는 이유를 뭉개버리는 짓이다
// 추가적인 공간을 사용하지 않고 정렬할 수 있다
// 
// 2. In-Place Sort
// 
// 퀵 소트는 '추가적인 공간'이 필요하지 않다
// 배열 안에서의 자리 바꿈만이 필요하고
// 따라서 '캐시 히트 레이트'가 높아서 속도가 빠르다는 장점이 따라온다
//
// pivot을 올바른 위치에 놓는 것이다.
// 'pivot의 왼쪽은 작은수 오른쪽은 큰 수' -> 여기에 주목한다
// 양쪽 끝에 포인터를 두고, 적절하게 스왑해 준다.
// 
// pivot, left, right 가 있다고 했을 때
// left는 pivot 보다 큰 수가 나올때까지 이동 (오른쪽으로)
// right는 pivot 보다 작거나 같은 수가 나올때까지 이동 (왼쪽으로)
//
// @@ 모든 순간에서 left의 오른쪽에는 pivot보다 작은 수가 있고
// @@ right의 right의 왼쪽에는 pivot보다 큰 수가 있다는 사실에 집중하라
//
// L의 오른쪽에는 큰 수, R의 왼쪽에는 작은 수
// 교차했다는 것은 그 위치가 Pivot이 위치할 곳이라는 것이다
// 왜냐하면 R Pivot L 이렇게 위치할 것인데
// R 왼쪽에는 작은 수 L 오른쪽에는 큰 수 이렇게 되면 Pivot이 올바르게 위치했다는 것이 자연스럽기 때문이다.
//
// 주의 사항
// quick sort는 평균적으로 O(NlogN)이지만, 최악의 경우 O(N^2)이 된다
// 그게 언제냐면
// 예를 들어, 배열이 이미 정렬되어 있는 경우에 pivot을 항상 첫 번째 요소로 선택하면,
// 각 단계에서 pivot을 기준으로 배열이 분할될 때 항상 한 쪽은 비어있는 배열이 되고,
// 다른 한 쪽은 원래 배열보다 한 요소 작은 배열이 됩니다.
// 이 경우 분할된 배열의 크기가 원래 배열의 크기보다 한 요소 작아지므로,
// 분할이 log n 단계를 거치더라도 모든 요소가 한 번씩만 비교되는 것이 아니라,
// 각 단계에서 n 개의 요소가 비교되므로 총 비교 횟수는 n(n-1)/2 가 됩니다.
// 따라서 최악의 경우에는 O(n^2)의 시간 복잡도를 가지게 됩니다.
//
// Merge Sort vs Quick Sort
//
// 시간 복잡도 : O(NlogN) vs 최악 O(N^2) 평균 O(NlogN) (Cash Hit Rate가 높아 평균적으로 Merge 보다 빠름)
// 추가적으로 필요한 공간(Overhead) : O(N) (tmp 배열) vs O(1) (pivot, left, right 이런거 저장 - In Place Sort)
// Stable Sort 여부 : stable vs unStable
//
//