// basic sort
// 
// 1. 선택 정렬
// 
// 책장의 서로 다른 높이의 무작위 배치된 책을 정렬하라고 하면
// 가장 먼저 떠오르는 방식이 뭐임..?
// 
// 대부분은 가장 기다란걸 찾아서
// 가장 끝에 놓는 방식을 생각하지
// 
// 이게 '선택 정렬'
// 가장 짧거나 긴거를 '선택'하는 거니까
// 
// 2. 버블 정렬
//
// 앞에서부터 인접한 두 원소를 비교하며
// 큰 수를 오른쪽으로 스왑하면
// 결국 한바퀴 돌았을때는 가장 오른쪽에 제일 큰 값이 배치된다
// 
// 이게 '버블 정렬'
// 인접한 두 원소가 거품같다고 해서
// 
// 3. 병합 정렬
// 
// * 분할
// 크기 N의 배열이 있고, 이를 크기 1까지 분할한다
// 배열의 크기 N을 2^k개 라고 했을때
// 분할 과정에서 1 + 2 + 4 + 8 + ... + 2^k가 된다
// 등비수열의 합 공식에 의해 2^(k+1) - 1이 되고
// 이는 곧 2N - 1임을 말한다
// 따라서 병합 정렬의 '분할'은 시간복잡도 O(N)이다
// 
// * 병합
// 길이가 A, B인 두 정렬된 배열을 하나로 합치는 과정의
// 시간복잡도는 O(A + B)였다 -> Merge() 함수 참고
// O(1+1) + O(1+1) + O(1+1) + O(1+1) = O(8)
// O(2+2) + O(2+2) = O(8)
// O(4+4) = O(8)
// O(8)
// 이렇게 각 레벨에서 O(N)으로 병합하고
// 이는 K개가 있으므로
// O(N * K) -> 즉 O(N * logN)이 된다
// 따라서 병합 정렬의 '병합'은 시간복잡도 O(NlogN)이다
//
// => 총 시간 복잡도는 O(N) + O(NlogN) = O(NlogN)